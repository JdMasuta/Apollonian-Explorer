# Apollonian Gasket Visualization Tool - Design Specification

## 1. PROJECT OVERVIEW

An interactive web application for generating and analyzing Apollonian gaskets with sequence detection capabilities. The tool provides real-time visualization, circle selection, sequence highlighting, and data export functionality.

**Target Users**: Single-user desktop application
**Deployment**: Single-command deployment from monorepo
**Architecture**: Decoupled frontend/backend with REST API + WebSocket communication

---

## 2. TECHNICAL STACK

### Backend
- **Framework**: FastAPI (Python 3.11+)
- **Database**: SQLite3 (development/single-user), PostgreSQL (future production)
- **Math Libraries**: 
  - `fractions.Fraction` - Exact rational arithmetic for curvatures
  - NumPy - Array operations and numerical computations
  - Numba - JIT compilation for performance-critical loops
- **Future Optimization**: CuPy for GPU acceleration, multiprocessing
- **ORM**: SQLAlchemy 2.0+
- **Validation**: Pydantic v2

### Frontend
- **Framework**: React 18+
- **Build Tool**: Vite
- **State Management**: Zustand
- **Visualization**: react-konva (Canvas-based rendering)
- **UI Components**: Material-UI (MUI v5)
- **HTTP Client**: Axios
- **WebSocket**: native WebSocket API or socket.io-client

### Communication
- **REST API**: CRUD operations for gaskets, sequences, configurations
- **WebSocket**: Real-time streaming of computed circles during generation

### Development Tools
- **Monorepo Management**: npm/yarn workspaces or Turborepo
- **Backend Testing**: pytest, pytest-asyncio
- **Frontend Testing**: Vitest, React Testing Library
- **Code Quality**: ESLint, Prettier, Black, isort, mypy

---

## 3. PROJECT STRUCTURE

```
ap-gask/
‚îú‚îÄ‚îÄ DESIGN_SPEC.md                 # This file
‚îú‚îÄ‚îÄ README.md                    # Project overview and setup instructions
‚îú‚îÄ‚îÄ docker-compose.yml           # Optional: containerized deployment
‚îú‚îÄ‚îÄ package.json                 # Root workspace configuration
‚îú‚îÄ‚îÄ .gitignore
‚îú‚îÄ‚îÄ .env.example
‚îÇ
‚îú‚îÄ‚îÄ backend/
‚îÇ   ‚îú‚îÄ‚îÄ pyproject.toml           # Poetry or pip dependencies
‚îÇ   ‚îú‚îÄ‚îÄ requirements.txt
‚îÇ   ‚îú‚îÄ‚îÄ .env
‚îÇ   ‚îú‚îÄ‚îÄ main.py                  # FastAPI application entry point
‚îÇ   ‚îú‚îÄ‚îÄ config.py                # Environment and app configuration
‚îÇ   ‚îÇ
‚îÇ   ‚îú‚îÄ‚îÄ api/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ __init__.py
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ deps.py              # Dependency injection (DB sessions, etc.)
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ router.py            # Main API router aggregation
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ endpoints/
‚îÇ   ‚îÇ       ‚îú‚îÄ‚îÄ __init__.py
‚îÇ   ‚îÇ       ‚îú‚îÄ‚îÄ gaskets.py       # Gasket CRUD endpoints
‚îÇ   ‚îÇ       ‚îú‚îÄ‚îÄ circles.py       # Circle query endpoints
‚îÇ   ‚îÇ       ‚îú‚îÄ‚îÄ sequences.py     # Sequence detection/retrieval
‚îÇ   ‚îÇ       ‚îú‚îÄ‚îÄ export.py        # SVG/JSON/CSV export
‚îÇ   ‚îÇ       ‚îî‚îÄ‚îÄ websocket.py     # WebSocket streaming endpoint
‚îÇ   ‚îÇ
‚îÇ   ‚îú‚îÄ‚îÄ core/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ __init__.py
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ gasket_generator.py  # Core Apollonian gasket algorithm
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ descartes.py         # Descartes Circle Theorem implementation
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ sequence_detector.py # Sequence pattern detection
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ cache_manager.py     # Lookup table and caching logic
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ circle_math.py       # Circle geometry utilities
‚îÇ   ‚îÇ
‚îÇ   ‚îú‚îÄ‚îÄ db/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ __init__.py
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ base.py              # SQLAlchemy Base and engine setup
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ session.py           # Session management
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ models/
‚îÇ   ‚îÇ       ‚îú‚îÄ‚îÄ __init__.py
‚îÇ   ‚îÇ       ‚îú‚îÄ‚îÄ gasket.py        # Gasket model
‚îÇ   ‚îÇ       ‚îú‚îÄ‚îÄ circle.py        # Circle model
‚îÇ   ‚îÇ       ‚îú‚îÄ‚îÄ sequence.py      # Sequence model
‚îÇ   ‚îÇ       ‚îî‚îÄ‚îÄ cache.py         # Cache/lookup table model
‚îÇ   ‚îÇ
‚îÇ   ‚îú‚îÄ‚îÄ schemas/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ __init__.py
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ gasket.py            # Pydantic schemas for gasket
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ circle.py            # Pydantic schemas for circle
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ sequence.py          # Pydantic schemas for sequence
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ export.py            # Export format schemas
‚îÇ   ‚îÇ
‚îÇ   ‚îú‚îÄ‚îÄ services/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ __init__.py
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ gasket_service.py    # Business logic for gasket operations
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ sequence_service.py  # Sequence analysis orchestration
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ export_service.py    # Export generation (SVG, JSON, CSV)
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ cache_service.py     # Cache retrieval and storage
‚îÇ   ‚îÇ
‚îÇ   ‚îú‚îÄ‚îÄ utils/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ __init__.py
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ rational.py          # Fraction utilities
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ hash_utils.py        # Hashing for cache keys
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ svg_generator.py     # SVG rendering utilities
‚îÇ   ‚îÇ
‚îÇ   ‚îî‚îÄ‚îÄ tests/
‚îÇ       ‚îú‚îÄ‚îÄ __init__.py
‚îÇ       ‚îú‚îÄ‚îÄ conftest.py
‚îÇ       ‚îú‚îÄ‚îÄ test_gasket_generator.py
‚îÇ       ‚îú‚îÄ‚îÄ test_sequence_detector.py
‚îÇ       ‚îî‚îÄ‚îÄ test_api/
‚îÇ           ‚îú‚îÄ‚îÄ test_gaskets.py
‚îÇ           ‚îî‚îÄ‚îÄ test_sequences.py
‚îÇ
‚îú‚îÄ‚îÄ frontend/
‚îÇ   ‚îú‚îÄ‚îÄ package.json
‚îÇ   ‚îú‚îÄ‚îÄ vite.config.js
‚îÇ   ‚îú‚îÄ‚îÄ index.html
‚îÇ   ‚îú‚îÄ‚îÄ .env
‚îÇ   ‚îÇ
‚îÇ   ‚îú‚îÄ‚îÄ src/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ main.jsx             # React entry point
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ App.jsx              # Root component
‚îÇ   ‚îÇ   ‚îÇ
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ components/
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ GasketCanvas/
‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ GasketCanvas.jsx          # Main Konva canvas
‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ CircleLayer.jsx           # Renders circles
‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ ControlsOverlay.jsx       # Pan/zoom/reset controls
‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ useCanvasInteraction.js   # Custom hook for interactions
‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ ConfigurationPanel/
‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ ConfigurationPanel.jsx    # Initial curvatures input
‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ CurvatureInput.jsx        # Individual curvature field
‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ DepthSelector.jsx         # Recursion depth slider
‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ GenerateButton.jsx        # Trigger generation
‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ SequencePanel/
‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ SequencePanel.jsx         # Sequence list and controls
‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ SequenceTypeSelector.jsx  # Dropdown for sequence types
‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ SequenceList.jsx          # List of active sequences
‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ SequenceItem.jsx          # Single sequence with toggle
‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ ColorPicker.jsx           # Color selection for highlighting
‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ CircleDetails/
‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ CircleDetails.jsx         # Expandable tree view
‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ CircleInfo.jsx            # Circle properties display
‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ TangencyList.jsx          # List of tangent circles
‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ ParentLinks.jsx           # Parent circle navigation
‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ CircleListView/
‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ CircleListView.jsx        # Searchable circle list
‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ CircleListItem.jsx        # List item with selection
‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ SearchFilter.jsx          # Filter by properties
‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ ExportDialog/
‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ ExportDialog.jsx          # Export modal
‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ SVGExportOptions.jsx      # SVG-specific options
‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ DataExportOptions.jsx     # JSON/CSV options
‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ common/
‚îÇ   ‚îÇ   ‚îÇ       ‚îú‚îÄ‚îÄ LoadingSpinner.jsx
‚îÇ   ‚îÇ   ‚îÇ       ‚îú‚îÄ‚îÄ ErrorBoundary.jsx
‚îÇ   ‚îÇ   ‚îÇ       ‚îî‚îÄ‚îÄ Notification.jsx
‚îÇ   ‚îÇ   ‚îÇ
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ stores/
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ gasketStore.js       # Gasket configuration and data
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ sequenceStore.js     # Active sequences and highlighting
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ selectionStore.js    # Selected circles
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ uiStore.js           # UI state (loading, errors, panels)
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ canvasStore.js       # Canvas pan/zoom state
‚îÇ   ‚îÇ   ‚îÇ
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ services/
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ api.js               # Axios instance and interceptors
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ gasketService.js     # API calls for gaskets
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ sequenceService.js   # API calls for sequences
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ exportService.js     # Export API calls
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ websocketService.js  # WebSocket connection management
‚îÇ   ‚îÇ   ‚îÇ
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ hooks/
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ useGasketGeneration.js  # Gasket generation with WS
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ useSequenceDetection.js # Sequence detection logic
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ useCircleSelection.js   # Circle selection sync
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ useExport.js            # Export functionality
‚îÇ   ‚îÇ   ‚îÇ
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ utils/
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ colorSchemes.js      # Predefined color schemes
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ circleGeometry.js    # Client-side geometry utils
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ formatters.js        # Data formatting utilities
‚îÇ   ‚îÇ   ‚îÇ
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ styles/
‚îÇ   ‚îÇ       ‚îú‚îÄ‚îÄ theme.js             # MUI theme configuration
‚îÇ   ‚îÇ       ‚îî‚îÄ‚îÄ global.css           # Global styles
‚îÇ   ‚îÇ
‚îÇ   ‚îî‚îÄ‚îÄ tests/
‚îÇ       ‚îú‚îÄ‚îÄ components/
‚îÇ       ‚îî‚îÄ‚îÄ stores/
‚îÇ
‚îî‚îÄ‚îÄ scripts/
    ‚îú‚îÄ‚îÄ setup.sh                 # Initial project setup
    ‚îú‚îÄ‚îÄ deploy.sh                # Single-command deployment
    ‚îî‚îÄ‚îÄ migrate.sh               # Database migration script
```

---

## 4. DATABASE SCHEMA

### 4.1 Gaskets Table
Stores unique gasket configurations (initial curvatures).

```sql
CREATE TABLE gaskets (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    hash VARCHAR(64) UNIQUE NOT NULL,  -- SHA-256 of sorted initial curvatures
    initial_curvatures TEXT NOT NULL,   -- JSON array of Fraction strings ["1/2", "3/4", ...]
    num_circles INTEGER,                -- Total circles in default generation
    max_depth_cached INTEGER,           -- Maximum depth pre-computed
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    last_accessed_at TIMESTAMP,
    access_count INTEGER DEFAULT 1      -- For usage-based caching priority
);

CREATE INDEX idx_gaskets_hash ON gaskets(hash);
CREATE INDEX idx_gaskets_access_count ON gaskets(access_count DESC);
```

### 4.2 Circles Table
Stores all computed circles for each gasket.

```sql
CREATE TABLE circles (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    gasket_id INTEGER NOT NULL,
    generation INTEGER NOT NULL,        -- Depth level (0 = initial circles)
    curvature_num INTEGER NOT NULL,     -- Numerator of curvature fraction
    curvature_denom INTEGER NOT NULL,   -- Denominator of curvature fraction
    center_x_num INTEGER NOT NULL,      -- Center X coordinate (rational)
    center_x_denom INTEGER NOT NULL,
    center_y_num INTEGER NOT NULL,      -- Center Y coordinate (rational)
    center_y_denom INTEGER NOT NULL,
    radius_num INTEGER NOT NULL,        -- Radius (rational)
    radius_denom INTEGER NOT NULL,
    parent_ids TEXT,                    -- JSON array of parent circle IDs
    tangent_ids TEXT,                   -- JSON array of tangent circle IDs
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    
    FOREIGN KEY (gasket_id) REFERENCES gaskets(id) ON DELETE CASCADE
);

CREATE INDEX idx_circles_gasket_generation ON circles(gasket_id, generation);
CREATE INDEX idx_circles_curvature ON circles(curvature_num, curvature_denom);
CREATE INDEX idx_circles_gasket_id ON circles(gasket_id);
```

### 4.3 Sequences Table
Stores detected sequences and their metadata.

```sql
CREATE TABLE sequences (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    gasket_id INTEGER NOT NULL,
    sequence_type VARCHAR(50) NOT NULL, -- 'curvature', 'generation', 'fibonacci', 'residue', 'lineage'
    parameters TEXT,                    -- JSON for sequence-specific params (e.g., {"mod": 24, "residue": 5})
    circle_ids TEXT NOT NULL,           -- Ordered JSON array of circle IDs in sequence
    hash VARCHAR(64) UNIQUE,            -- Hash of (gasket_hash + sequence_type + parameters)
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    
    FOREIGN KEY (gasket_id) REFERENCES gaskets(id) ON DELETE CASCADE
);

CREATE INDEX idx_sequences_gasket_type ON sequences(gasket_id, sequence_type);
CREATE INDEX idx_sequences_hash ON sequences(hash);
```

### 4.4 Cache Metadata Table
Tracks cache performance and prioritization.

```sql
CREATE TABLE cache_metadata (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    entity_type VARCHAR(20) NOT NULL,   -- 'gasket', 'sequence'
    entity_id INTEGER NOT NULL,
    computation_time_ms FLOAT,          -- Time saved by caching
    size_bytes INTEGER,                 -- Memory footprint
    last_hit_at TIMESTAMP,
    hit_count INTEGER DEFAULT 0,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

CREATE INDEX idx_cache_entity ON cache_metadata(entity_type, entity_id);
CREATE INDEX idx_cache_hit_count ON cache_metadata(hit_count DESC);
```

---

## 5. API ENDPOINTS

### 5.1 REST API

#### Gaskets
- `POST /api/gaskets` - Create/retrieve gasket from initial curvatures
  - Request: `{ "curvatures": ["1", "1", "1"], "max_depth": 5 }`
  - Response: `{ "id": 1, "hash": "...", "circles": [...] }`
  
- `GET /api/gaskets/{id}` - Retrieve gasket by ID
  - Response: Full gasket with circles up to cached depth
  
- `GET /api/gaskets/{id}/circles` - Get circles with filters
  - Query params: `?generation=2&min_curvature=10&max_curvature=100`
  
- `DELETE /api/gaskets/{id}` - Delete gasket and associated data

#### Sequences
- `POST /api/sequences/detect` - Detect sequence in gasket
  - Request: `{ "gasket_id": 1, "sequence_type": "curvature", "parameters": {...} }`
  - Response: `{ "sequence_id": 1, "circles": [...], "metadata": {...} }`
  
- `GET /api/sequences/{id}` - Retrieve sequence by ID
  
- `GET /api/gaskets/{id}/sequences` - List all sequences for gasket
  - Query params: `?type=fibonacci`
  
- `DELETE /api/sequences/{id}` - Remove sequence

#### Export
- `POST /api/export/svg` - Generate SVG export
  - Request: `{ "gasket_id": 1, "depth": 8, "width": 2000, "height": 2000, "highlighted_sequences": [1, 2] }`
  - Response: SVG file download
  
- `POST /api/export/json` - Export gasket data as JSON
  - Response: JSON with full circle data and generation tree
  
- `POST /api/export/csv` - Export circles as CSV
  - Response: CSV file with circle properties

#### Configuration
- `GET /api/config/sequence-types` - List available sequence types
- `GET /api/config/color-schemes` - List preset color schemes

### 5.2 WebSocket API

#### `/ws/gasket/generate`
Real-time gasket generation streaming.

**Client ‚Üí Server:**
```json
{
  "action": "start",
  "curvatures": ["1", "1", "1", "1"],
  "max_depth": 10
}
```

**Server ‚Üí Client (streamed):**
```json
{
  "type": "progress",
  "generation": 3,
  "circles_count": 156,
  "circles": [
    { "id": 157, "curvature": "3/2", "center": {"x": "1/4", "y": "1/3"}, "radius": "2/3", ... }
  ]
}
```

**Server ‚Üí Client (completion):**
```json
{
  "type": "complete",
  "gasket_id": 1,
  "total_circles": 1248,
  "computation_time_ms": 523.4
}
```

---

## 6. FRONTEND COMPONENT HIERARCHY

```
App
‚îú‚îÄ‚îÄ Layout (MUI Container/Grid)
‚îÇ   ‚îú‚îÄ‚îÄ Header
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ AppBar with title
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ Configuration quick access
‚îÇ   ‚îÇ
‚îÇ   ‚îú‚îÄ‚îÄ MainContent (Grid container)
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ LeftPanel (Grid item, 30%)
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ ConfigurationPanel
‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ CurvatureInput (x3 or x4)
‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ DepthSelector
‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ GenerateButton
‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ SequencePanel
‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ SequenceTypeSelector
‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ DetectButton
‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ SequenceList
‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ       ‚îî‚îÄ‚îÄ SequenceItem (repeating)
‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ           ‚îú‚îÄ‚îÄ ColorPicker
‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ           ‚îú‚îÄ‚îÄ VisibilityToggle
‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ           ‚îî‚îÄ‚îÄ RemoveButton
‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ CircleListView
‚îÇ   ‚îÇ   ‚îÇ       ‚îú‚îÄ‚îÄ SearchFilter
‚îÇ   ‚îÇ   ‚îÇ       ‚îî‚îÄ‚îÄ VirtualizedList
‚îÇ   ‚îÇ   ‚îÇ           ‚îî‚îÄ‚îÄ CircleListItem (repeating)
‚îÇ   ‚îÇ   ‚îÇ
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ CenterPanel (Grid item, 50%)
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ GasketCanvas
‚îÇ   ‚îÇ   ‚îÇ       ‚îú‚îÄ‚îÄ Stage (Konva)
‚îÇ   ‚îÇ   ‚îÇ       ‚îÇ   ‚îî‚îÄ‚îÄ Layer
‚îÇ   ‚îÇ   ‚îÇ       ‚îÇ       ‚îî‚îÄ‚îÄ Circle (repeating, Konva.Circle)
‚îÇ   ‚îÇ   ‚îÇ       ‚îÇ
‚îÇ   ‚îÇ   ‚îÇ       ‚îî‚îÄ‚îÄ ControlsOverlay
‚îÇ   ‚îÇ   ‚îÇ           ‚îú‚îÄ‚îÄ ZoomIn/Out buttons
‚îÇ   ‚îÇ   ‚îÇ           ‚îú‚îÄ‚îÄ ResetView button
‚îÇ   ‚îÇ   ‚îÇ           ‚îî‚îÄ‚îÄ LoadingIndicator
‚îÇ   ‚îÇ   ‚îÇ
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ RightPanel (Grid item, 20%)
‚îÇ   ‚îÇ       ‚îú‚îÄ‚îÄ CircleDetails
‚îÇ   ‚îÇ       ‚îÇ   ‚îú‚îÄ‚îÄ Accordion (Sequence Info)
‚îÇ   ‚îÇ       ‚îÇ   ‚îú‚îÄ‚îÄ Accordion (Circle Properties)
‚îÇ   ‚îÇ       ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ Curvature display
‚îÇ   ‚îÇ       ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ Center coordinates
‚îÇ   ‚îÇ       ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ Radius
‚îÇ   ‚îÇ       ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ Generation
‚îÇ   ‚îÇ       ‚îÇ   ‚îÇ
‚îÇ   ‚îÇ       ‚îÇ   ‚îú‚îÄ‚îÄ Accordion (Parent Links)
‚îÇ   ‚îÇ       ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ ParentLinks (clickable)
‚îÇ   ‚îÇ       ‚îÇ   ‚îÇ
‚îÇ   ‚îÇ       ‚îÇ   ‚îî‚îÄ‚îÄ Accordion (Tangencies)
‚îÇ   ‚îÇ       ‚îÇ       ‚îî‚îÄ‚îÄ TangencyList (clickable)
‚îÇ   ‚îÇ       ‚îÇ
‚îÇ   ‚îÇ       ‚îî‚îÄ‚îÄ ExportButton
‚îÇ   ‚îÇ           ‚Üí Opens ExportDialog
‚îÇ   ‚îÇ
‚îÇ   ‚îî‚îÄ‚îÄ Footer
‚îÇ       ‚îî‚îÄ‚îÄ Status bar (generation stats, cache hits)
‚îÇ
‚îî‚îÄ‚îÄ Dialogs
    ‚îú‚îÄ‚îÄ ExportDialog
    ‚îÇ   ‚îú‚îÄ‚îÄ TabPanel (SVG)
    ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ SVGExportOptions
    ‚îÇ   ‚îî‚îÄ‚îÄ TabPanel (Data)
    ‚îÇ       ‚îî‚îÄ‚îÄ DataExportOptions
    ‚îÇ
    ‚îî‚îÄ‚îÄ ErrorDialog
```

---

## 7. STATE MANAGEMENT (ZUSTAND STORES)

### 7.1 gasketStore
```javascript
{
  currentGasket: {
    id: number | null,
    hash: string,
    initialCurvatures: string[],  // Fraction strings
    maxDepth: number,
    circles: Circle[],             // All circles for current gasket
    generationCounts: number[]     // Circles per generation
  },
  
  config: {
    curvatures: string[],          // User input
    depth: number,                 // Recursion depth
    isGenerating: boolean,
    progress: number               // 0-100
  },
  
  actions: {
    setConfiguration: (curvatures, depth) => void,
    generateGasket: () => Promise<void>,
    loadGasket: (id) => Promise<void>,
    clearGasket: () => void
  }
}
```

### 7.2 sequenceStore
```javascript
{
  sequences: {
    [sequenceId]: {
      id: number,
      type: string,
      parameters: object,
      circleIds: number[],
      color: string,
      visible: boolean
    }
  },
  
  highlightSettings: {
    defaultColor: '#E3DE9C',
    presetColors: ['#9E59D9', '#D874A6', '#DCA26D', '#8FC986', '#609BD8'],
    hideNonSequence: boolean
  },
  
  actions: {
    detectSequence: (type, parameters) => Promise<void>,
    toggleSequence: (id) => void,
    removeSequence: (id) => void,
    setSequenceColor: (id, color) => void,
    setHideNonSequence: (hide) => void
  }
}
```

### 7.3 selectionStore
```javascript
{
  selectedCircleId: number | null,
  selectedCircle: Circle | null,  // Full circle data with relationships
  
  actions: {
    selectCircle: (id) => void,
    clearSelection: () => void
  }
}
```

### 7.4 canvasStore
```javascript
{
  transform: {
    x: number,              // Pan offset X
    y: number,              // Pan offset Y
    scale: number           // Zoom level
  },
  
  viewport: {
    width: number,
    height: number
  },
  
  actions: {
    setTransform: (x, y, scale) => void,
    resetView: () => void,
    panBy: (dx, dy) => void,
    zoomAt: (x, y, scaleDelta) => void
  }
}
```

### 7.5 uiStore
```javascript
{
  loading: boolean,
  error: string | null,
  notification: { message: string, severity: 'info' | 'success' | 'error' } | null,
  
  panels: {
    configOpen: boolean,
    sequenceOpen: boolean,
    detailsOpen: boolean
  },
  
  dialogs: {
    exportOpen: boolean
  },
  
  actions: {
    setLoading: (loading) => void,
    setError: (error) => void,
    showNotification: (message, severity) => void,
    togglePanel: (panel) => void,
    openDialog: (dialog) => void,
    closeDialog: (dialog) => void
  }
}
```

---

## 8. ALGORITHMS

### 8.1 Descartes Circle Theorem
**Purpose**: Calculate the curvature of the fourth circle tangent to three mutually tangent circles.

**Formula**:
Given three circles with curvatures k‚ÇÅ, k‚ÇÇ, k‚ÇÉ, the curvature k‚ÇÑ of the two circles tangent to all three:

```
k‚ÇÑ = k‚ÇÅ + k‚ÇÇ + k‚ÇÉ ¬± 2‚àö(k‚ÇÅk‚ÇÇ + k‚ÇÇk‚ÇÉ + k‚ÇÉk‚ÇÅ)
```

**Complex Descartes Theorem** (for centers):
Given centers as complex numbers z‚ÇÅ, z‚ÇÇ, z‚ÇÉ with curvatures k‚ÇÅ, k‚ÇÇ, k‚ÇÉ:

```
k‚ÇÑz‚ÇÑ = k‚ÇÅz‚ÇÅ + k‚ÇÇz‚ÇÇ + k‚ÇÉz‚ÇÉ ¬± 2‚àö(k‚ÇÅk‚ÇÇz‚ÇÅz‚ÇÇ + k‚ÇÇk‚ÇÉz‚ÇÇz‚ÇÉ + k‚ÇÉk‚ÇÅz‚ÇÉz‚ÇÅ)
```

**Implementation Strategy**:
- Use `fractions.Fraction` for all curvature calculations
- For position calculations, represent complex numbers as tuples of Fractions: `(real_frac, imag_frac)`
- Cache square root approximations for common values
- Numba JIT compile for performance

### 8.2 Gasket Generation Algorithm
**Recursive approach**:

```python
def generate_gasket(initial_curvatures: List[Fraction], max_depth: int):
    # Start with 3-4 initial circles
    circles = initialize_circles(initial_curvatures)
    queue = [(circles[0], circles[1], circles[2], 0)]  # (c1, c2, c3, depth)
    
    while queue:
        c1, c2, c3, depth = queue.pop(0)
        
        if depth >= max_depth:
            continue
        
        # Apply Descartes theorem to find two new circles
        k4_plus, z4_plus = descartes_solve(c1, c2, c3, sign=+1)
        k4_minus, z4_minus = descartes_solve(c1, c2, c3, sign=-1)
        
        # Check if circles already exist (hash-based deduplication)
        if not exists(k4_plus, z4_plus):
            new_circle_plus = create_circle(k4_plus, z4_plus, depth+1)
            circles.append(new_circle_plus)
            yield new_circle_plus  # Stream to client via WebSocket
            
            # Add new triplets to queue
            queue.extend([
                (c1, c2, new_circle_plus, depth+1),
                (c2, c3, new_circle_plus, depth+1),
                (c3, c1, new_circle_plus, depth+1)
            ])
        
        # Repeat for k4_minus
        ...
    
    return circles
```

**Optimization**:
- Use spatial hashing to detect duplicate circles (tolerance for floating-point comparison)
- Parallelize triplet processing at deeper levels
- Store circle hashes in set for O(1) existence checks

### 8.3 Sequence Detection Algorithms

#### 8.3.1 Curvature Sequence
Identifies circles following the recurrence: `a(n) = 4a(n-1) - a(n-2)`

```python
def detect_curvature_sequence(circles: List[Circle], seed_curvatures: Tuple[Fraction, Fraction]):
    k0, k1 = seed_curvatures
    sequence = [find_circle_by_curvature(k0), find_circle_by_curvature(k1)]
    
    for i in range(2, len(circles)):
        k_next = 4 * sequence[-1].curvature - sequence[-2].curvature
        circle = find_circle_by_curvature(k_next)
        if circle:
            sequence.append(circle)
        else:
            break
    
    return sequence
```

#### 8.3.2 Generation-Based Sequence
All circles at a specific depth level.

```python
def detect_generation_sequence(circles: List[Circle], generation: int):
    return [c for c in circles if c.generation == generation]
```

#### 8.3.3 Fibonacci-Related Patterns
Circles with curvatures matching Fibonacci relationships.

```python
def detect_fibonacci_sequence(circles: List[Circle]):
    # Find circles where curvature = F(n) or related to Fibonacci
    # Implementation depends on specific pattern definition
    pass
```

#### 8.3.4 Residue Class Patterns (mod 24)
Circles with curvatures ‚â° r (mod 24).

```python
def detect_residue_sequence(circles: List[Circle], modulus: int, residue: int):
    return [c for c in circles if (c.curvature.numerator % modulus) == residue]
```

#### 8.3.5 Parent-Child Lineage Chains
Traces a path through parent relationships.

```python
def detect_lineage_sequence(circles: List[Circle], start_circle: Circle):
    sequence = [start_circle]
    current = start_circle
    
    while current.parent_ids:
        parent = find_circle_by_id(current.parent_ids[0])
        sequence.insert(0, parent)
        current = parent
    
    return sequence
```

---

## 9. CACHING AND OPTIMIZATION STRATEGY

### 9.1 Lookup Table Strategy
**Goal**: The more the application is used, the more lookups occur vs. computations.

**Key Components**:
1. **Gasket Hash**: SHA-256 of sorted initial curvatures (canonical form)
2. **Sequence Hash**: SHA-256 of (gasket_hash + sequence_type + parameters)
3. **LRU Cache**: In-memory cache for hot gaskets (Redis for production)

**Workflow**:
1. User requests gasket with curvatures `[k1, k2, k3]` and depth `d`
2. Compute hash: `hash = sha256(sorted([k1, k2, k3]))`
3. Check database for existing gasket with hash
4. If found and `max_depth_cached >= d`: Return from DB (cache hit)
5. If found but `max_depth_cached < d`: Generate additional levels, update cache
6. If not found: Full generation, store in DB
7. Update `access_count` and `last_accessed_at` for cache management

### 9.2 Performance Optimizations

#### Backend
- **Numba JIT**: Compile Descartes theorem calculations
- **NumPy Vectorization**: Batch process circle properties
- **Multiprocessing**: Parallelize independent triplet expansions
- **Future GPU**: CuPy for large-scale batch computations
- **Database Indexing**: Compound indexes on (gasket_id, generation)
- **Connection Pooling**: SQLAlchemy async pool for concurrent requests

#### Frontend
- **Canvas Rendering**: react-konva for hardware-accelerated 2D
- **Virtualization**: React-window for large circle lists
- **Debouncing**: Debounce pan/zoom events (16ms / 60fps)
- **Web Workers**: Offload heavy computations (future)
- **Incremental Rendering**: Stream circles from WebSocket, render in batches

### 9.3 Cache Eviction Policy
- **Priority**: `score = hit_count / age_days * (1 + size_penalty)`
- Evict lowest-scoring gaskets when storage exceeds threshold
- Always preserve gaskets accessed in last 7 days
- Option for manual cache clearing in admin panel (future)

---

## 10. IMPLEMENTATION PHASES

### Phase 0: Project Setup (Day 1)
**Goal**: Establish monorepo structure and tooling.

**Tasks**:
1. Initialize monorepo with npm workspaces
2. Set up backend with FastAPI + SQLAlchemy
3. Set up frontend with Vite + React + MUI
4. Configure ESLint, Prettier, Black, isort
5. Create `setup.sh` and `deploy.sh` scripts
6. Initialize git repository with .gitignore
7. Write README.md with setup instructions

**Deliverables**:
- Working dev environment for both frontend and backend
- Single-command startup: `npm run dev` (runs both)

---

### Phase 1: Core Gasket Generation (Days 2-4)
**Goal**: Implement mathematical foundation and basic generation.

**Backend Tasks**:
1. Implement `descartes.py` with Fraction-based calculations
   - Curvature solver
   - Complex Descartes for positions
   - Unit tests for known configurations
2. Implement `gasket_generator.py`
   - Recursive generation algorithm
   - Depth limiting
   - Circle deduplication
3. Create database models (Gasket, Circle)
4. Implement `gaskets.py` API endpoint
   - POST /api/gaskets
   - GET /api/gaskets/{id}
5. Add basic caching (hash lookup)

**Frontend Tasks**:
1. Create `gasketStore` with Zustand
2. Build `ConfigurationPanel` component
   - Curvature inputs (default: [1, 1, 1])
   - Depth selector (default: 5, range: 1-12)
3. Build basic `GasketCanvas` with Konva
   - Render circles from store
   - Auto-fit viewport
4. Implement `gasketService.js` API client
5. Connect generate button to API

**Testing**:
- Verify gasket with (1, 1, 1) generates correct circles
- Test depth levels: 3, 5, 7, 10
- Verify circle counts match expected values

**Deliverables**:
- Working gasket generation from curvatures
- Circles displayed on canvas
- Data persisted to database

---

### Phase 2: WebSocket Streaming (Days 5-6)
**Goal**: Real-time progress updates during generation.

**Backend Tasks**:
1. Implement WebSocket endpoint `/ws/gasket/generate`
2. Modify generator to yield circles incrementally
3. Stream circles to client as they're computed
4. Send progress updates (generation, count)

**Frontend Tasks**:
1. Create `websocketService.js`
2. Build `useGasketGeneration` hook
   - Connect to WebSocket
   - Update store as circles arrive
   - Handle completion/errors
3. Add loading indicator and progress bar
4. Update canvas to render incrementally

**Testing**:
- Generate depth-10 gasket, verify smooth streaming
- Test connection drops and reconnection
- Verify final gasket matches REST API result

**Deliverables**:
- Real-time circle rendering during generation
- Progress feedback to user

---

### Phase 3: Canvas Interactions (Days 7-8)
**Goal**: Pan, zoom, and circle selection.

**Frontend Tasks**:
1. Implement pan/zoom in `GasketCanvas`
   - Mouse drag to pan
   - Mouse wheel to zoom
   - Touch gestures (future)
2. Build `canvasStore` for transform state
3. Implement circle click detection
   - Konva onClick handlers
   - Map canvas coords to circles
4. Build `selectionStore`
5. Highlight selected circle (thicker border)
6. Add `ControlsOverlay` with reset/zoom buttons

**Testing**:
- Pan and zoom smoothly at 60fps
- Click small circles accurately
- Verify selection persists during pan/zoom

**Deliverables**:
- Fully interactive canvas
- Circle selection working

---

### Phase 4: Sequence Detection (Days 9-11)
**Goal**: Implement all sequence types and detection.

**Backend Tasks**:
1. Create `sequence_detector.py` with all algorithms:
   - Curvature sequences
   - Generation-based
   - Fibonacci-related
   - Residue class (mod 24)
   - Parent-child lineage
2. Create Sequence database model
3. Implement `sequences.py` API endpoints
   - POST /api/sequences/detect
   - GET /api/sequences/{id}
   - GET /api/gaskets/{id}/sequences
4. Add sequence caching (hash-based)
5. Unit tests for each sequence type

**Frontend Tasks**:
1. Create `sequenceStore`
2. Build `SequencePanel` components
   - SequenceTypeSelector dropdown
   - Detect button
   - SequenceList with items
3. Implement highlighting logic
   - Apply colors to sequence circles
   - Toggle visibility
4. Build `ColorPicker` component
5. Implement "hide non-sequence" mode

**Testing**:
- Detect curvature sequence starting from (1, 1)
- Verify generation-based sequences match expected circles
- Test residue classes mod 24
- Verify highlighting colors apply correctly

**Deliverables**:
- All 5 sequence types working
- Visual highlighting on canvas
- Sequence management panel

---

### Phase 5: Circle Details and List View (Days 12-13)
**Goal**: Display detailed circle information and list navigation.

**Frontend Tasks**:
1. Build `CircleDetails` component
   - Expandable accordions
   - Display curvature, center, radius, generation
   - Parent links (clickable ‚Üí select parent)
   - Tangency list (clickable ‚Üí select tangent)
2. Build `CircleListView` component
   - Virtualized list of all circles
   - Search/filter by properties
   - Click to select circle
3. Sync selection between canvas, list, and details
4. Implement navigation via parent/tangent links

**Backend Tasks**:
1. Add endpoint for circle relationships: GET /api/circles/{id}
2. Return parent and tangent circle IDs with full details

**Testing**:
- Click circle on canvas ‚Üí details update
- Click circle in list ‚Üí canvas highlights
- Navigate parent chain
- Filter circles by generation

**Deliverables**:
- Full circle information display
- Synchronized multi-view selection
- Relationship navigation

---

### Phase 6: Export Functionality (Days 14-15)
**Goal**: SVG, JSON, and CSV export.

**Backend Tasks**:
1. Implement `svg_generator.py`
   - Render circles as SVG `<circle>` elements
   - Apply highlighting to sequences
   - Configurable canvas size
2. Implement `export_service.py`
   - SVG generation with depth control
   - JSON export (full gasket data)
   - CSV export (circle properties)
3. Create export endpoints
   - POST /api/export/svg
   - POST /api/export/json
   - POST /api/export/csv

**Frontend Tasks**:
1. Build `ExportDialog` component
   - Tabs for SVG, JSON, CSV
   - Options for each format
   - Depth selector for SVG
   - Sequence inclusion toggles
2. Implement `useExport` hook
3. Trigger downloads from API responses

**Testing**:
- Export SVG at depth 8, verify rendering in Inkscape/browser
- Export JSON, verify structure and completeness
- Export CSV, verify columns and data
- Test with and without highlighted sequences

**Deliverables**:
- Working export for all three formats
- User-configurable export options

---

### Phase 7: Advanced Caching (Days 16-17)
**Goal**: Optimize lookup table and cache management.

**Backend Tasks**:
1. Implement `cache_service.py`
   - Hash-based gasket retrieval
   - Sequence caching
   - Cache hit tracking
2. Add cache_metadata table
3. Implement cache eviction policy
4. Add cache statistics endpoint: GET /api/cache/stats
5. Optimize database queries with proper indexing

**Frontend Tasks**:
1. Display cache statistics in footer
2. Add cache clear option (future admin panel)

**Testing**:
- Generate same gasket twice, verify cache hit
- Detect same sequence twice, verify instant retrieval
- Monitor computation time savings
- Test cache eviction under storage pressure

**Deliverables**:
- Functional cache system
- Measurable performance improvements

---

### Phase 8: Polish and Testing (Days 18-20)
**Goal**: Bug fixes, UX improvements, comprehensive testing.

**Tasks**:
1. Error handling and user feedback
   - API error messages
   - Network failure handling
   - Validation errors
2. Loading states and skeletons
3. Responsive layout (desktop only, but different screen sizes)
4. Keyboard shortcuts (future)
5. Comprehensive test suite
   - Backend: pytest for all core algorithms
   - Frontend: Vitest for store logic
   - Integration tests for API
6. Documentation
   - Code comments
   - API documentation (OpenAPI/Swagger)
   - User guide in README
7. Performance profiling
   - Identify bottlenecks
   - Optimize rendering
   - Database query optimization

**Deliverables**:
- Production-ready application
- Full test coverage
- Documentation complete

---

### Phase 9: Deployment (Day 21)
**Goal**: Single-command deployment script.

**Tasks**:
1. Create `deploy.sh` script
   - Build frontend (Vite)
   - Copy static files to backend
   - Set up production SQLite database
   - Run migrations
   - Start FastAPI with Uvicorn
2. Configure production settings
   - Environment variables
   - Logging
   - CORS settings
3. Test deployment on clean machine
4. Write deployment documentation

**Deliverables**:
- `./scripts/deploy.sh` runs entire application
- Production-ready build

---

## 11. KEY TECHNICAL DECISIONS

### 11.1 Exact Rational Arithmetic
**Why**: Apollonian gasket curvatures are exactly rational numbers. Using floating-point arithmetic introduces cumulative errors, especially at deeper recursion levels.

**Implementation**: 
- Use Python's `fractions.Fraction` for all curvature values
- Represent circle centers as tuples of Fractions: `(Fraction(x_num, x_denom), Fraction(y_num, y_denom))`
- Store numerator and denominator separately in database for lossless persistence
- Convert to float only for rendering

### 11.2 Canvas-Based Rendering (react-konva)
**Why**: 
- Superior performance for rendering 1000+ circles compared to SVG DOM
- Hardware-accelerated transformations (pan/zoom)
- Built-in event handling for interactions
- Easy integration with React

**Alternative Considered**: D3.js with SVG (rejected due to DOM performance overhead)

### 11.3 WebSocket for Real-Time Streaming
**Why**:
- Deep gaskets (depth 10+) can take several seconds to generate
- Streaming circles as they're computed provides immediate feedback
- User can see gasket "growing" in real-time
- Alternative (polling) would be inefficient and delayed

### 11.4 Monorepo with Workspaces
**Why**:
- Single source of truth for the project
- Shared configuration and tooling
- Simplified deployment (single repo to clone)
- Easy cross-referencing between frontend and backend

**Structure**: npm workspaces with `backend/` and `frontend/` packages

### 11.5 Hash-Based Caching
**Why**:
- Apollonian gaskets are deterministic: same initial curvatures ‚Üí same gasket
- Hashing initial curvatures creates a unique identifier
- Enables instant retrieval of previously computed gaskets
- Reduces redundant computation as usage grows

**Hash Algorithm**: SHA-256 of canonical (sorted) initial curvatures

### 11.6 Zustand for State Management
**Why**:
- Lightweight (< 1KB) compared to Redux
- Simple API with minimal boilerplate
- Easy integration with React hooks
- Sufficient for single-user desktop application
- Better performance than Context API for frequent updates

---

## 12. FUTURE ENHANCEMENTS (Out of Scope for MVP)

### Performance
- GPU acceleration with CuPy for massive gaskets
- Web Workers for background sequence detection
- WASM port of core algorithms (Rust/C++)
- Distributed computation (future multi-user)

### Features
- 3D Apollonian sphere packing
- Animation of gasket construction
- Custom sequence definitions (user-defined patterns)
- Algebraic properties analysis (bend, residue patterns)
- Fractal dimension calculation
- Comparison tool for multiple gaskets
- Preset gallery of interesting configurations

### Deployment
- Multi-user support with authentication
- PostgreSQL migration for production
- Docker containerization
- Cloud deployment (AWS/GCP/Azure)
- CDN for static assets

### UI/UX
- Mobile/tablet support (touch gestures)
- Dark mode
- Keyboard shortcuts
- Undo/redo for operations
- Session persistence (save workspace)
- Collaborative features (future)

---

## 13. DEPENDENCIES

### Backend (requirements.txt)
```
fastapi>=0.104.0
uvicorn[standard]>=0.24.0
sqlalchemy>=2.0.0
pydantic>=2.4.0
pydantic-settings>=2.0.0
python-multipart>=0.0.6
websockets>=12.0
numpy>=1.24.0
numba>=0.58.0
pytest>=7.4.0
pytest-asyncio>=0.21.0
httpx>=0.25.0
```

### Frontend (package.json)
```json
{
  "dependencies": {
    "react": "^18.2.0",
    "react-dom": "^18.2.0",
    "react-konva": "^18.2.10",
    "konva": "^9.2.0",
    "@mui/material": "^5.14.0",
    "@mui/icons-material": "^5.14.0",
    "@emotion/react": "^11.11.0",
    "@emotion/styled": "^11.11.0",
    "zustand": "^4.4.0",
    "axios": "^1.6.0",
    "react-window": "^1.8.10"
  },
  "devDependencies": {
    "vite": "^5.0.0",
    "@vitejs/plugin-react": "^4.2.0",
    "vitest": "^1.0.0",
    "@testing-library/react": "^14.1.0",
    "eslint": "^8.54.0",
    "prettier": "^3.1.0"
  }
}
```

---

## 14. COLOR SCHEMES

### Default Highlight
- Background: `#E3DE9C` (soft yellow)
- Border: 3px solid, same color

### Preset Colors
- Purple: `#9E59D9`
- Pink: `#D874A6`
- Orange: `#DCA26D`
- Green: `#8FC986`
- Blue: `#609BD8`

### Circle Rendering
- **Normal circles**: White fill, thin black border (1px)
- **Highlighted circles**: Colored fill (opaque), thick colored border (3px)
- **Selected circle**: Additional gold border (5px)

### Color Assignment
- Sequences assigned colors in order from preset list
- After 5 sequences, allow custom color picker
- User can override any sequence color

---

## 15. CONFIGURATION DEFAULTS

### Gasket Generation
- **Initial Curvatures**: `["1", "1", "1"]` (three mutually tangent circles)
- **Default Depth**: 5 (light recursion)
- **Depth Ranges**:
  - Light: 5-7 levels (~100-500 circles)
  - Medium: 8-10 levels (~1,000-5,000 circles)
  - Heavy: 11+ levels (~10,000+ circles)

### Canvas
- **Default Viewport**: Fit all circles with 10% padding
- **Zoom Range**: 0.1x to 10x
- **Pan**: Unlimited (no bounds)
- **Reset View**: Fit all circles

### Sequences
- **Default Type**: Curvature sequence
- **Auto-detect on Generation**: No (manual trigger)
- **Max Sequences**: Unlimited (practical limit: 20 for UI clarity)

### Export
- **SVG Size**: 2000x2000px (configurable)
- **SVG Depth**: Current gasket depth (adjustable)
- **JSON Format**: Pretty-printed, indentation 2
- **CSV Columns**: id, generation, curvature, center_x, center_y, radius, parent_ids

---

## 16. ERROR HANDLING

### Backend
- **Invalid Curvatures**: Return 400 with message
- **Database Errors**: Return 500 with generic message, log details
- **Computation Timeout**: Return 504 after 60 seconds
- **WebSocket Errors**: Send error message, close connection gracefully

### Frontend
- **Network Errors**: Display toast notification, allow retry
- **Invalid Input**: Inline validation messages
- **Generation Failure**: Show error dialog with details
- **WebSocket Disconnect**: Auto-reconnect with exponential backoff

---

## 17. TESTING STRATEGY

### Unit Tests
- Backend: All core algorithms (Descartes, generators, detectors)
- Frontend: Store logic, utility functions

### Integration Tests
- API endpoints with test database
- WebSocket communication flow

### End-to-End Tests (Future)
- Full user workflows (generate ‚Üí detect ‚Üí export)
- Playwright or Cypress

### Performance Tests
- Benchmark generation times for standard depths
- Measure cache hit ratios
- Profile rendering performance

---

## 18. DEPLOYMENT SCRIPT (deploy.sh)

```bash
#!/bin/bash
set -e

echo "üöÄ Deploying Apollonian Gasket Visualizer..."

# 1. Install backend dependencies
echo "üì¶ Installing backend dependencies..."
cd backend
pip install -r requirements.txt
cd ..

# 2. Build frontend
echo "üî® Building frontend..."
cd frontend
npm install
npm run build
cd ..

# 3. Copy frontend build to backend static folder
echo "üìÇ Copying frontend build..."
mkdir -p backend/static
cp -r frontend/dist/* backend/static/

# 4. Set up database
echo "üóÑÔ∏è  Setting up database..."
cd backend
python -c "from db.base import create_tables; create_tables()"
cd ..

# 5. Start backend server
echo "‚úÖ Starting server..."
cd backend
uvicorn main:app --host 0.0.0.0 --port 8000

echo "üéâ Deployment complete! Visit http://localhost:8000"
```

---

## 19. MAINTENANCE AND EXTENSIBILITY

### Adding New Sequence Types
1. Implement detection algorithm in `sequence_detector.py`
2. Add new sequence type to enum/config
3. Register type in `/api/config/sequence-types` endpoint
4. Add UI option in `SequenceTypeSelector`
5. Write unit tests for detection logic

### Porting to Production (PostgreSQL)
1. Update `config.py` with PostgreSQL connection string
2. Adjust SQLAlchemy dialect-specific features (if any)
3. Run migration script
4. Update backup strategy

### Optimization Opportunities
- Profile with `cProfile` and `line_profiler`
- Identify hot paths in generation loop
- Consider Cython for critical sections
- Add Redis for distributed caching

### Modular Design
- Core algorithms isolated in `core/` package
- Easy to extract and rewrite in another language (Rust, C++)
- Clear interfaces between layers (API ‚Üî Service ‚Üî Core)

---

## 20. SUCCESS METRICS

### Performance Targets
- Depth 7 gasket: < 500ms generation time
- Depth 10 gasket: < 5s generation time
- Canvas rendering: 60fps during pan/zoom
- Cache hit ratio: > 50% after 100 gaskets generated

### User Experience
- Single-command deployment works on fresh system
- Sequence detection: < 1s for any type
- Export generation: < 3s for depth-10 SVG
- UI responsiveness: All interactions < 100ms

---

## CONCLUSION

This design specification provides a complete blueprint for implementing an Apollonian gasket visualization tool. The architecture prioritizes:

1. **Mathematical Correctness**: Exact rational arithmetic
2. **Performance**: Caching, streaming, optimization
3. **Usability**: Interactive canvas, multiple views, rich data display
4. **Maintainability**: Modular design, clear separation of concerns
5. **Extensibility**: Easy to add new sequence types, export formats, optimizations

The phased implementation plan allows for incremental development with working deliverables at each stage. The monorepo structure with single-command deployment ensures ease of use for the end user.
